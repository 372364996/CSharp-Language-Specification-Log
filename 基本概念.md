# 基本概念

## 应用程序入口点方法Main

具有下列签名之一：

```
static void Main(){...}
static void Main(string[] args){...}
static int Main(){...}
static int Main(string[] args){...}
```

1. string\[\] args参数：
   1. 由执行环境创建并传递一个包含**命令行实参**的string\[\]实参，命令行实参是在启动应用程序时指定的。
   2. string\[\]参数永远不能为null，没有指定则长度为0；
2. Main方法的重载：  
   1. 可以定义多个Main方法，需要通过某种外部机制（例如命令行编译器选项）来选择其中一个Main方法作为入口点；

   1. 执行环境访问入口点方法会忽略可访问性和封闭它的类型的可访问性；

   2. 应用程序入口点方法**不能位于泛型类声明中**；

3. 应用程序终止与Main返回值void、int：

   1. Main方法返回int：应用程序终止时返回的值用作终止状态码返回给执行环境；执行环境可根据该值判断应用程序运行状态；

   2. Mian方法返回void：应用程序终止时将产生终止状态码0；

   3. 在应用程序终止之前，将**调用还没有被垃圾回收的所有对象的析构函数**；

## 声明

C\#程序使用命名空间组织起来的，一个命名空间可以包含类型声明和嵌套的命名空间声明。

类型声明用于定义类、结构、接口、枚举和委托。

类声明可以包含常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数、析构函数和嵌套类型声明。

## 成员

1. 命名空间成员
   1. 全局命名空间（global namespace）成员：命名空间和类型没有封闭它的命名空间，就属于全局命名空间的成员；
   2. 命名空间**没有访问限制**，始终是公开可访问的；
2. 结构成员：包含结构中声明的成员以及继承自结构的直接基类System.ValueType和间接基类object的成员；
3. 枚举成员：在枚举中声明的**常量**以及继承自枚举的直接基类System.Enum和间接基类System.ValueType和object的成员；
4. 类成员
   1. 类中声明的成员（类声明可以包含常量、字段、方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数、析构函数和嵌套类型声明）；
   2. 从基类继承的成员（包括基类的常量、字段、方法、属性、事件、索引器、运算符和嵌套类，与可访问性无关），但**不包含实例构造函数、静态构造函数和析构函数**；
5. 接口成员：包含接口本身和所有基接口中声明的成员；
6. 数组成员：从**类System.Array**继承的成员；
7. 委托成员：从**类System.Delegate**继承的成员；

## 成员的可访问性

成员可访问性：

* public：公开的，没有限制；
* protected：受保护的，限定于该类及派生类；
* internal：内部的，限定于当前程序集内部；
* protected internal：内部受保护的，限定于当前程序集内部的该类及派生类；
* provate：私有的，限定于该类内部；

上下文设置的默认可访问性：

* 命名空间不允许使用访问修饰符，默认隐式具有public；
* 命名空间中声明的类型默认具有internal；只能显示声明为public或internal；
* 类成员默认具有private；可显示声明为以上5中访问修饰符；
* 结构成员默认具有private；可显示声明为public、internal或private；**结构是隐式密封的**；
* 接口成员默认具有public；接口成员声明时**不允许使用访问修饰符**；
* 枚举成员默认具有public；枚举成员声明时**不允许使用访问修饰符**；

可访问性约束（ &gt;= 表示至少具有同样的可访问性；上面的**成员可访问性**也是从高到底排序的）：

* 直接基类 &gt;= 派生类；显示基接口 &gt;= 派生接口；

* 委托类型的**返回值和参数类型** &gt;= 委托类型本身；方法的**返回值和参数类型** &gt;= 方法本身；运算符的**返回类型和参数类型** &gt;= 运算符本身；

  ```
  class A {...}
  public class B
  {
      A F() {...}
      internal A G() {...}
      public A H() {...}    //错误，因为类型A并不具有至少与该方法相同的可访问性；
  }
  ```

* 常量的**类型** &gt;= 常量本身；字段的**类型** &gt;= 字段本身；属性的**类型** &gt;= 属性本身；事件的**类型** &gt;= 事件本身；

* 索引器的**类型和参数** &gt;= 索引器本身；

* 实例构造函数的**参数** &gt;= 实例构造函数本身；

## 签名和重载

方法、实例构造函数、索引器和运算符是由**签名**来刻画的：

* 方法签名：由**方法名称**、**形参的个数**和它**每个形参的类型**和**形参的传递模式**（值传递、引用传递、out、ref）组成，不包含返回类型、params修饰符和可选类型形参约束。
* 实例构造函数签名：由**每个形参类型**和**形参的传递模式**组成，不包含params修饰符。
* 索引器签名：由**每个形参的类型**组成，不包含元素类型和params修饰符。

* 运算符签名：由**运算符的名称**和它的**每个形参的类型**组成，不包含结果类型。

签名是对类、结构和接口的成员实施**重载**的机制，重载允许声明多个方法、实例构造函数、索引器和运算符，前提是签名是唯一的。

虽然out和ref参数修饰符被视为签名的一部分，但同一个类型中的成员不能仅通过out和ref在签名上加以区分:

```
interface ITest
{
	void F();			// F()
	void F(int x);			// F(int)
	void F(ref int x);		// F(ref int)
	void F(out int x);		// F(out int)  	error  不能仅通过out和ref在签名上加以区分
	void F(int x, int y);		// F(int, int)
	int F(string s);		// F(string)
	int F(int x);			// F(int)	error  方法签名不包含返回值类型
	void F(string[] a);		// F(string[])
	void F(params string[] a);	// F(string[])	error  方法签名不包含params参数修饰符
}
```



