# 分部类型

partial不是关键字，仅当它在class、struct或interface之前出现在类型声明中或void之前出现在方法声明中时充当修饰符。

只有一个类型声明时，partial修饰符也是有效的。

分部类型的所有部分必须一起编译，以便在编译时合并为单个类型。

分部类型不允许对已经编译的类型进行扩展。

嵌套类型可以使用partial声明，并且每个部分均在类型的不同部分中（外围类也是分部类）声明。

委托和枚举声明时不允许使用partial修饰符。

## 特性

分部类型的特性是通过组合每个部分的特性来确定的。类型形参的特性同理。

## 修饰符

分部类型的可访问性必须一致。

如果分部类型的一个或多个部分声明使用了abstract修饰符，则该类为抽象类，否则为非抽象类。

如果分部类型的一个或多个部分声明使用了sealed修饰符，则该类为密封类，否则为非密封类。

当unsafe修饰符用于某个分部类时，只有该部分才是不安全的上下文。

## 类型形参和约束

## 基类

分部类型声明基类时，必须所有部分都有一致的基类声明，否则基类为object。

## 基接口

分部类型的基接口集是每部分中指定的基接口的并集（组合每个部分的基接口）。

一个特定基接口在每个部分只能指定一次，但允许多个部分指定相同的基接口。

任何基接口的成员在所有部分中**只能有一个实现**。

```
partial class C : IA, IB {...}
partial class C : IC {...}
partial class C : IA, IB {...}    //类C的基接口集为IA, IB 和 IC。
```

在一个部分中可以提供在另一个部分上声明的基接口的实现。

```
partial class C : IComparable {...}
partial class C 
{
    int IComparable.CompareTo(object o) {...}
}
```

## 成员

除了分部方法，其他类型的成员集是每个部分中声明的成员的并集（组合每个部分的成员）。

在一个分部类型中声明的private成员可从其他部分随意访问。在多个部分中声明同一个成员会引起编译错误。

## 分部方法

分部方法可以在一个部分中声明，在另外的部分中实现；实现是可选的，如果所有部分中都没有实现分部方法，则编译器在组合各部分的类型声明中，移除分部方法声明和所有对它的调用。

分部方法不能定义访问修饰符，**隐含为private**，他们的**返回类型必须是void**。而且形参不能带out修饰符。

分部方法不能显示实现接口方法（因为接口方法必须实现）。

有两种分部方法声明：

1. 定义分部方法声明：方法声明体是一个分号；在分部类型的所有部分中**只能有一个**。
2. 实现分部方法声明：以block形式给定声明体；在分部类型的所有部分中**只能有一个**。

以上两种分部方法声明必须符合以下条件：

* 具有相同的修饰符、方法名、类型形参数目和形参数目；
* 形参必须具有相同的修饰符和相同的类型；
* 类型形参必须具有相同的约束；

## 名称绑定

当解释一个部分中的简单名称时，只考虑包容该部分的命名空间定义的using指令。

```
namesapce N
{
    using List = System.Collections.ArrayList;
    partial class A
    {
        List X;        //x的类型是System.Collections.ArrayList
    }
}

namespace N
{
    using List = Widgets.LinkedList;
    partial class A
    {
        List y;        //y的类型是Widgets.LinkedList
    }
}
```



